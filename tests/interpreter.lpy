; metacircular lispy interpreter written in lispy with a repl

(define eval-expr [node env]
    (do 
    ;(println node)
    (cond
        (nil? node) ()
        (int? node) node
        (float? node) node
        ; variable 
        (symbol? node) (get env node)

        ; list forms
        (list? node)
            (switch (car node)
                ('quote node)
                ('if 
                    (if (eval-expr (cadr node) env) 
                    (eval-expr (car (cddr node)) env)
                    (eval-expr (cadr (cddr node)) env))
                )
                ('define (add-env (cadr node) (eval-expr (car (cddr node)) env)))
                ('fn
                    (do
                        (define params (cadr node))
                        (define body (car (cddr node)))
                        ; return a function which will be the operator when apply is called
                        (fn [& args]
                            (do 
                                ;arguments
                                ; why does this only execute with prinln wtf
                                (println (set-new-env env (cadr (car node)) args))
                                (println env)
                                ; body 
                                (eval-expr (car (cddr (car node))) env) 
                            )
                        )
                    )
                )


                ; evaluate function call
                ((car node)
                    (do
                        (define operator (eval-expr (car node) env))
                        (define operands (cdr node))
                        (if (= (caar node) 'fn)
                            (do
                                (operator 5)
                            )
                            (apply operator (apply-compound env operands))
                        )
                    )
                )
            )
    )
    )
)

(define apply-compound [env args]
    (if (nil? args)
        ()
        (cons (eval-expr (car args) env) (apply-compound env (cdr args)))
    )
)

;simplify rn by just straight up updating new-env (otherwise match env to what?) but nested not sure?
(define add-env [env key val]
    (do
        (swap env (add env key val))
        val
    )
)
;parameters are named variables passed to the functions, arguments are actual valus
(define set-new-env [env params arguments]
    (if (nil? params) 
        ()
        (do
            (println (str "p: " params))
            (println (str "a: " arguments))
            (set-new-env (cdr params) (cdr arguments))
            (add-env env (car params) (car arguments))
        )
    )
)

(define env 
    (hash-map
        '+ +
        '- -
        '/ /
        '* *
        '= =
    )
)


(define eval [source]
    (eval-expr source env)
)


(define repl-loop [line]
    (do
        (println "lispy> ")
        ; readstring parses into an ast 
        (define source (readstring (readline)))
        (println (eval source))
        ;uncomment for debugging to see env (println new-env)
        (repl-loop source)
    )
)
(repl-loop "")
;(eval '(define a 5))
;(eval '(+ a 10))
;(eval '(* 1 2))
;(eval '5)
;(eval '6.0)
;(eval '(if (false) 5 6))



